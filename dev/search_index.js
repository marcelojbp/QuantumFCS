var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumFCS.fcscumulants_recursive","category":"page"},{"location":"api/#QuantumFCS.fcscumulants_recursive","page":"API","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC, rho_ss, nu)\nfcscumulants_recursive(H, J, mJ, nC, rho_ss, nu)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse or dense, ComplexF64)\n\nAlternatively, one can provide the Hamiltonian and jump operators instead of L\n\nH: Hamiltonian operator (sparse or dense, Operator from QuantumOptics.jl)\nJ: Vector of jump operators (sparse or dense, Operator from QuantumOptics.jl)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nrho_ss: Steady-state density matrix (sparse or dense, ComplexF64)\nnu: Vector of length length(mJ) with weights for each jump.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This package provides tools to compute full-counting-statistics cumulants from a Liouvillian.","category":"page"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To install the package, in the Julia REPL, ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"] add https://github.com/marcelojbp/QuantumFCS","category":"page"},{"location":"quickstart/#Quickstart-example","page":"Quickstart","title":"Quickstart example","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We model a quantum dot heat engine as a single mode coupled to two reservoirs (hot and cold) in the large bias limit (n_c = 0 n_h = 1).","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using QuantumOptics \nusing QuantumFCS\n# Basis for the single quantum dot\nb = FockBasis(1)\n# Operators \nd = destroy(b)\nd_dag = create(b)\nid = identityoperator(b)\n# Parameters\nϵd = 1.0;                            # Energy level of the quantum dot\nκc = 0.1;                            # Coupling strength to cold reservoir\nκh = 0.5;                            # Coupling strength to hot reservoir\n# Hamiltonian and jump operators\nH = ϵd * d_dag * d;                  \nJcloss = sqrt(κc) * d;               # Jumps into the cold reservoir \nJhgain = sqrt(κh) * d_dag;           # Jumps from the hot reservoir\nJ = [Jcloss, Jhgain];\n# Steady state\nρss = steadystate.iterative(H, J)\n# Weight vector \nnu = [1];\n# Monitored jump operator (particles entering the cold reservoir)\nmJ = [Jcloss];\n# Calculating the first two cumulants\nc1, c2 = fcscumulants_recursive(H, J, mJ, 2, ρss, nu);\nprintln(\"\\nFull Counting Statistics:\")\nprintln(\"First cumulant : $c1\")\nprintln(\"Second cumulant : $c2\") ","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Quantum-dot-heat-engine","page":"Examples","title":"Quantum dot heat engine","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We study a quantum dot coupled to two fermionic reservoirs, for details on the model see Patrick P. Potts, 2024. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QuantumFCS, LinearAlgebra, SparseArrays\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define parameters and system","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# System parameters\nϵd = 1.0;  # Energy level of the quantum dot\nκc = 0.1;  # Coupling strength to cold reservoir\nκh = 0.5;  # Coupling strength to hot reservoir\nnc = 0.0;  # Occupation number of cold reservoir\nnh = 1.0;  # Occupation number of hot reservoir\n\n# Basis states and identity \noccupied = complex.([0,1]);\nempty = complex.([1,0]);\nid = sparse(1.0I,2,2);\n\n## Operators\n# Hamiltonian \nH = sparse(ϵd * (occupied * occupied'))  \n# Jump operators\nJcloss = sparse(sqrt(κc * (1-nc)) * (empty * occupied'));\nJcgain = sparse(sqrt(κc * nc) * (occupied * empty'));\nJhgain = sparse(sqrt(κh * nh) * (occupied * empty'));\nJhloss = sparse(sqrt(κh * (1-nh)) * (empty * occupied'));","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We construct the Liouvillian ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"## Constructing the Liouvillian\n# Unitary part \nL = -im * (kron(id,H) - kron(transpose(H),id))\n# Jump terms from the dissipators \nL += kron(conj(Jcloss),Jcloss) + kron(conj(Jhloss),Jhloss) + kron(conj(Jhgain),Jhgain)\n# Non-jump terms from the dissipators\nL += (-1/2 * kron(id,Jcloss'*Jcloss) \n     -1/2 * kron(transpose(Jcloss'*Jcloss),id) \n     -1/2 * kron(id,Jcgain'*Jcgain) \n     -1/2 * kron(transpose(Jcgain'*Jcgain),id) \n     -1/2 * kron(id,Jhloss'*Jhloss) \n     -1/2 * kron(transpose(Jhloss'*Jhloss),id)\n     -1/2 * kron(id,Jhgain'*Jhgain) \n     -1/2 * kron(transpose(Jhgain'*Jhgain),id))  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and determine the steady state ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":" # Determining the steady state\nE = eigen(Matrix(L))                       # compute all eigenpairs (fine for small L)\nidx = argmin(abs.(E.values))               # index of eigenvalue closest to zero\nv = E.vectors[:, idx]                      # right eigenvector (vec(ρ))\n\n# reshape back to n×n (vec stacks columns, so reshape(v, n, n) gives the matrix)\nρ_ss = reshape(v, 2, 2);\n\n# numeric cleanup: make Hermitian and normalize trace\nρ_ss = (ρ_ss + ρ_ss') / 2  ;               # enforce Hermiticity (conjugate-transpose)\nρ_ss = ρ_ss / tr(ρ_ss) ;                   # normalize trace to 1","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We choose to monitor the electrons entering the cold reservoir ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Vector with weights \nnu = [1];\n\n# Monitored jump operators (photons entering the cold reservoir)\nmJ = [Jcloss];","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Computing the first two cumulants\nc1, c2 = fcscumulants_recursive(L, mJ, 2, sparse(ρ_ss), nu);\nprintln(\"\\nFull Counting Statistics (numerics):\")\nprintln(\"First cumulant : $c1\")\nprintln(\"Second cumulant : $c2\") ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full Counting Statistics (numerics):\nFirst cumulant : 0.08333333333333334\nSecond cumulant : 0.06018518518518519","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the large bias regime we have the following analytical solutions Patrick P. Potts, 2024","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"c1_analytical = κc*κh/(κc+κh);\nc2_analytical = (κh^2+κc^2)/(κc+κh)^2*c1_analytical;\nprintln(\"\\nFull Counting Statistics (analytical):\")\nprintln(\"First cumulant : $c1_analytical\")\nprintln(\"Second cumulant : $c2_analytical\") ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full Counting Statistics (analytical):\nFirst cumulant : 0.08333333333333334\nSecond cumulant : 0.0601851851851852","category":"page"},{"location":"examples/#Driven-cavity","page":"Examples","title":"Driven cavity","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We study a simple driven cavity using the QuantumOptics.jl package to model the system","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QuantumOptics\nusing QuantumFCS","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define parameters and system ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# Define the Hilbert space dimension \nN = 10  # Fock space cutoff\n\n# Create the Fock basis for the cavity mode\nbasis = FockBasis(N)\n\n# Define operators\na = destroy(basis)  # annihilation operator\na_dag = create(basis)  # creation operator\nn = number(basis)   # number operator\n\n# System parameters\nω = 1.0     # cavity frequency\nκ = 0.1     # cavity decay rate\nΩ = 0.5     # drive strength (coherent drive)\n\n# Hamiltonian (driven cavity)\nH = ω * n + Ω * (a_dag + a)  # free evolution + coherent drive\n\n# Jump operators (cavity decay)\nJ = [sqrt(κ) * a]  # photon loss\n\n# Vector with weights (for one monitored channel)\nnu = [-1]\n\n# Monitored jump operators (photons leaving the cavity)\nmJ = [sqrt(κ) * a]\n\n# Initial state (vacuum state)\nψ0 = fockstate(basis, 0)\nρ0 = dm(ψ0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Determine the steady state ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ρss = steadystate.iterative(H, J);\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Compute the first three cumulants","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"c1, c2, c3 = fcscumulants_recursive(H, J, mJ, 3, ρss, nu)\n\nprintln(\"\\nFull Counting Statistics:\")\nprintln(\"First cumulant (mean photon flux): $c1\")\nprintln(\"Second cumulant (variance): $c2\") \nprintln(\"Third cumulant (skewness): $c3\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full Counting Statistics:\nFirst cumulant (mean photon flux): -0.02104572040194588\nSecond cumulant (variance): 0.012890993774510551\nThird cumulant (skewness): 0.011185533737017767","category":"page"},{"location":"math/#math","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"As a general scenario, we consider a Lindblad master equation,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"mathcalLrho = fracd rhodt = -iH rho + sum_k=1^r L_k  rho  L_k^dagger - frac12L^dagger_k L_k rho ","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"We introduce p le r integrated currents N_k with weights nu_k. This lets us define the total integrated current,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"N(t) = sum_k=1^p nu_k  N_k(t)","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"Above, nu_k can be simply integers, e.g. pm 1 to count electrons/photons, or have units to count electric charges (e) and  stochastic heat/work (energy). ","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"We further define the n-resolved density matrix rho_n(t) whose trace equals the probability to have accumulated n jumps at time t, P(nt) = operatornameTrrho_n(t). Summing over the set of allowed values mathcalN for the total charge N, we retrieve the standard density matrix,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"rho(t) = sum_n in mathcalN rho_n(t)","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"We now consider the Fourier transform of the n-resolved density matrix,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"rho_chi(t) = sum_n in mathcalN e^i n chi  rho_n(t)","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"where chi is called the counting field and the time evolution of rho_chi(t) is given by the generalized master equation (GME),","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"mathcalL_chi  rho_chi = bigl(mathcalL + delta mathcalL_chibigr)rho_chi","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"where","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"delta mathcalL_chi = sum_k=1^pbigl(1-e^inu_k chibigr)  L_k  (cdot)  L_k^dagger","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"Computing cumulants using recursive methods","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"We are ultimately interested in the n-th cumulant langlelangle I^n ranglerangle of the stochastic current,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"I(t) = fracdNdt","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"which we compute through the following recursive scheme,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"langlelangle I^n ranglerangle = sum_m=1^n binomnm  langlelangle mathbb1   mathcalL^(m)   rho_textss^(n-m)(chi) ranglerangle","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"with the constituents,","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":" rho_textss^(n)(chi) ranglerangle = mathcalL^+ sum_m=1^n binomnm Bigl( langlelangle I^m ranglerangle - mathcalL^(m)Bigr)  rho_textss^(n-m) ranglerangle","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"mathcalL^(n) = bigl(-i  partial_chibigr)^n mathcalL_chi Big_chi to 0","category":"page"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"and mathcalL^+ being the Drazin inverse of mathcalL.","category":"page"},{"location":"math/#References","page":"Mathematical Background","title":"References","text":"","category":"section"},{"location":"math/","page":"Mathematical Background","title":"Mathematical Background","text":"FCS in Lindblad master equations: Potts (2024). \"Quantum Thermodynamics\" arXiv\nFCS, recursive scheme, vectorization, Drazin inverse: Landi et al. (2024). \"Current fluctuations in open quantum systems: Bridging the gap between quantum continuous measurements and full counting statistics\", PRX Quantum 5, 020201 (2024) arXiv \nDetailed exposition of the recursive scheme: Flindt et al. (2010). \"Counting statistics of transport through Coulomb blockade nanostructures: High-order cumulants and non-Markovian effects\" Phys. Rev. B 82, 155407 arXiv","category":"page"},{"location":"#QuantumFCS.jl","page":"Home","title":"QuantumFCS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.jl provides tools for Full Counting Statistics (FCS) of quantum systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"-⚡ Start with the Quickstart","category":"page"},{"location":"","page":"Home","title":"Home","text":"-📘 Read up on the Mathematical Background","category":"page"},{"location":"","page":"Home","title":"Home","text":"-🧭 Browse the API","category":"page"},{"location":"","page":"Home","title":"Home","text":"-📝 Study the Examples","category":"page"}]
}
