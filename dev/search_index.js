var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumFCS]\nOrder   = [:module, :type, :function, :constant]","category":"page"},{"location":"api/#QuantumFCS.drazin-NTuple{4, Any}","page":"API","title":"QuantumFCS.drazin","text":"drazin(L, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nL : Liouvillian matrix\nvrho_ss: vectorised density matrix specifying the steady-state of the Liouvillian.\nvId: vectorised identity matrix (1√óN row or vector)\nIdL: Identity matrix in Liouville space (N√óN)\n\nReturns\n\nDrazin inverse as a (sparse)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.drazin_apply-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, AbstractVector{ComplexF64}}","page":"API","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of the Liouvillean L to the vector Œ± by solving a linear system.\n\nArguments\n\nL: Liouvillean operator (matrix).\nŒ±: Right-hand side vector.\nœÅ: Steady-state vector.\nvId: Vectorized identity vector.\nF: Optional factorization of L to reuse (default: nothing).\nrtol: Relative tolerance for the solver (default: 1e-12).\natol: Absolute tolerance for the solver (default: 0.0).\n\nReturns\n\nA (sparse) vector representing the result of applying the projected Drazin inverse.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.fcscumulants_recursive-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}, Integer, SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, AbstractVector{<:Real}}","page":"API","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse or dense, ComplexF64)\n\nAlternatively, one can provide the Hamiltonian and jump operators instead of L\n\nH: Hamiltonian operator (sparse or dense, Operator from QuantumOptics.jl)\nJ: Vector of jump operators (sparse or dense, Operator from QuantumOptics.jl)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.m_jumps-Tuple{AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}}","page":"API","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ‚Ñí(n) = ‚àë‚Çñ (ŒΩ‚Çñ)‚Åø (L‚Çñ*)‚äóL‚Çñ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights ŒΩ‚Çñ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This package provides tools to compute full-counting-statistics cumulants from a Liouvillian.","category":"page"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To install the package, in the Julia REPL, ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"] add https://github.com/marcelojbp/QuantumFCS","category":"page"},{"location":"quickstart/#Quickstart-examples","page":"Quickstart","title":"Quickstart examples","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using QuantumFCS\n\n# Build your Liouvillian L and monitored jumps mJ\n# L     : Complex sparse/dense matrix   (vectorized Liouvillian)\n# mJ    : Vector of sparse jump super-operators you want to monitor\n# nC    : Number of cumulats to be computed\n# rho_ss : Steady-state density matrix (matrix, not vectorized)\n# nu     : Vector of weighs (same length as mJ) for the monitored jumps\n\nmJ = [sqrt(kappa) * a, sqrt(kappa) * a_dagger] #Monitoring loss and injection of photons\nnu = [-1, 1] #We count -1 if we anihilate and +1 if we create\n# compute first 3 cumulants\nc1, c2, c3 = fcscumulants_recursive(L, mJ, 3, rho_ss, nu)\n\n#In case you want to use QuantumOptics.jl;\nusing QuantumOptics\n\n# H :: QuantumOptics.Operator Define your Hamiltonian as a Quantum Optics Operator type\n# J :: Vector{QuantumOptics.Operator} Define your vector containing the jump opterators \n# mJ:: Vector{QuantumOptics.Operator} Define your vector containing the monitored jump operators \n# rho_ss ::QuantumOptics.Operator steady-state density operator\n\nmJ = [sqrt(kappa) * a, sqrt(kappa) * a_dagger] #Same as above, but here a and a_dagger are QuantumOptics.Operators\nnu = [-1, 1] #Same as above\n\nc1, c2, c3 = fcscumulants_recursive(H, J, mJ, 3, rho_ss, nu)\n","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Driven-cavity","page":"Examples","title":"Driven cavity","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QuantumOptics\nusing QuantumFCS","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define parameters and system ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# Define the Hilbert space dimension \nN = 10  # Fock space cutoff\n\n# Create the Fock basis for the cavity mode\nbasis = FockBasis(N)\n\n# Define operators\na = destroy(basis)  # annihilation operator\na_dag = create(basis)  # creation operator\nn = number(basis)   # number operator\n\n# System parameters\nœâ = 1.0     # cavity frequency\nŒ∫ = 0.1     # cavity decay rate\nŒ© = 0.5     # drive strength (coherent drive)\n\n# Hamiltonian (driven cavity)\nH = œâ * n + Œ© * (a_dag + a)  # free evolution + coherent drive\n\n# Jump operators (cavity decay)\nJ = [sqrt(Œ∫) * a]  # photon loss\n\n# Counting field vector (for one monitored channel)\nnu = [-1]\n\n# Monitored jump operators (photons leaving the cavity)\nmJ = [sqrt(Œ∫) * a]\n\n# Initial state (vacuum state)\nœà0 = fockstate(basis, 0)\nœÅ0 = dm(œà0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Determine the steady state ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"œÅss = steadystate.iterative(H, J);\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Compute the first three cumulants","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"c1, c2, c3 = fcscumulants_recursive(H, J, mJ, 3, œÅss, nu)\n\nprintln(\"\\nFull Counting Statistics:\")\nprintln(\"First cumulant (mean photon flux): $c1\")\nprintln(\"Second cumulant (variance): $c2\") \nprintln(\"Third cumulant (skewness): $c3\")\n","category":"page"},{"location":"examples/#Quantum-dot-heat-engine","page":"Examples","title":"Quantum dot heat engine","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"TBA","category":"page"},{"location":"#QuantumFCS.jl","page":"Home","title":"QuantumFCS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.jl provides tools for Full Counting Statistics (FCS) of quantum systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"-üìò Start with the Quickstart","category":"page"},{"location":"","page":"Home","title":"Home","text":"-üß≠ Browse the API","category":"page"},{"location":"","page":"Home","title":"Home","text":"-üìù Study the Examples","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#The-math-behind","page":"Home","title":"The math behind","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a general scenario, we consider a Lindblad master equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalLrho = fracd rhodt = -iH rho + sum_k=1^r L_k  rho  L_k^dagger - frac12L^dagger_k L_k rho ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We introduce p le r counting fields N_k with weights nu_k. This lets us define the total current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"N(t) = sum_k nu_k  N_k(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We further define the n-resolved density matrix rho_n(t) whose trace equals the probability to have accumulated n jumps at time t, P(nt) = operatornameTrrho_n(t). Summing over the set of allowed values mathcalN for the total charge N, we retrieve the standard density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho(t) = sum_n in mathcalN rho_n(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We now consider the Fourier transform of the n-resolved density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho_chi(t) = sum_n in mathcalN e^i n chi  rho_n(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"is called the counting field and the time evolution of rho_chi(t) is given by the generalized master equation (GME),","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL_chi  rho_chi = bigl(mathcalL + delta mathcalL_chibigr)rho_chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta mathcalL_chi = sum_k=1^pbigl(1-e^inu_k chibigr)  L_k  (cdot)  L_k^dagger","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computing cumulants using recursive methods","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are ultimately interested in the n-th cumulant langlelangle I^n ranglerangle of the stochastic current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"I(t) = fracdNdt","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we compute through the following recursive scheme,","category":"page"},{"location":"","page":"Home","title":"Home","text":"langlelangle I^n ranglerangle = sum_m=1^n binomnm  langlelangle mathbb1   mathcalL^(m)   rho_textss^(n-m)(chi) ranglerangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"with the constituents,","category":"page"},{"location":"","page":"Home","title":"Home","text":" rho_textss^(n)(chi) ranglerangle = mathcalL^+ sum_m=1^n binomnm Bigl( langlelangle I^m ranglerangle - mathcalL^(m)Bigr)  rho_textss^(n-m) ranglerangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL^(n) = bigl(-i  partial_chibigr)^n mathcalL_chi Big_chi to 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and mathcalL^+ being the Drazin inverse of mathcalL.","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.fcscumulants_recursive","category":"page"},{"location":"#QuantumFCS.fcscumulants_recursive","page":"Home","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse or dense, ComplexF64)\n\nAlternatively, one can provide the Hamiltonian and jump operators instead of L\n\nH: Hamiltonian operator (sparse or dense, Operator from QuantumOptics.jl)\nJ: Vector of jump operators (sparse or dense, Operator from QuantumOptics.jl)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin","category":"page"},{"location":"#QuantumFCS.drazin","page":"Home","title":"QuantumFCS.drazin","text":"drazin(L, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nL : Liouvillian matrix\nvrho_ss: vectorised density matrix specifying the steady-state of the Liouvillian.\nvId: vectorised identity matrix (1√óN row or vector)\nIdL: Identity matrix in Liouville space (N√óN)\n\nReturns\n\nDrazin inverse as a (sparse)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.m_jumps","category":"page"},{"location":"#QuantumFCS.m_jumps","page":"Home","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ‚Ñí(n) = ‚àë‚Çñ (ŒΩ‚Çñ)‚Åø (L‚Çñ*)‚äóL‚Çñ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights ŒΩ‚Çñ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin_apply","category":"page"},{"location":"#QuantumFCS.drazin_apply","page":"Home","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of the Liouvillean L to the vector Œ± by solving a linear system.\n\nArguments\n\nL: Liouvillean operator (matrix).\nŒ±: Right-hand side vector.\nœÅ: Steady-state vector.\nvId: Vectorized identity vector.\nF: Optional factorization of L to reuse (default: nothing).\nrtol: Relative tolerance for the solver (default: 1e-12).\natol: Absolute tolerance for the solver (default: 0.0).\n\nReturns\n\nA (sparse) vector representing the result of applying the projected Drazin inverse.\n\n\n\n\n\n","category":"function"}]
}
