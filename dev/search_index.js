var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumFCS]\nOrder   = [:module, :type, :function, :constant]","category":"page"},{"location":"api/#QuantumFCS.drazin-NTuple{4, Any}","page":"API","title":"QuantumFCS.drazin","text":"drazin(H, J, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary        operator type.\nrho_ss: Density matrix specifying the steady-state of the Liouvillian. By default, it is found through steadystate.eigenvector.         For large matrices the steady-state should be provided, as the best steady-state solver could vary.\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.drazin_apply-Tuple{Matrix{ComplexF64}, AbstractVector{ComplexF64}, SparseArrays.SparseVector{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}","page":"API","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing)\n\nFast apply of the (projected) Drazin inverse for dense L.\n\nL :: Matrix{ComplexF64}\nŒ± :: AbstractVector{ComplexF64}         (dense RHS)\nœÅ :: SparseVector{ComplexF64,Int}       (steady state, sparse)\nvId :: SparseVector{ComplexF64,Int}     (vectorized identity, sparse)\nF :: Union{Nothing,LU}                  (cached lu(L))\n\nReturns Vector{ComplexF64} (type-stable, dense).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.drazin_apply-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, AbstractVector{ComplexF64}}","page":"API","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of L to Œ± by solving a linear system.\n\nL::SparseMatrixCSC{ComplexF64,Int} (can reuse with F = factorize(L))\nŒ±::SparseVector{ComplexF64,Int}\nœÅ::SparseVector{ComplexF64,Int}   (the steady-state vector)\nvId::AbstractVector{ComplexF64}   (gauge vector)\nF::Union{Nothing,Factorization} (optional factorization of L to reuse)\n\nReturns a SparseVector{ComplexF64,Int} (type-stable).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.fcscumulants_recursive-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}, Integer, SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}","page":"API","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse, ComplexF64)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump matrix. By default down jumps have weight -1 and up-jumps have weight +1.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.m_jumps-Tuple{AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}}","page":"API","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ‚Ñí(n) = ‚àë‚Çñ (ŒΩ‚Çñ)‚Åø (L‚Çñ*)‚äóL‚Çñ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights ŒΩ‚Çñ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator. By default down jumps, J, have weight +1 and up-jumps have weight -1.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This package provides tools to compute full-counting-statistics cumulants from a Liouvillian.","category":"page"},{"location":"quickstart/#Minimal-examples","page":"Quickstart","title":"Minimal examples","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using QuantumFCS\n\n# Build your Liouvillian L and monitored jumps mJ\n# L      :: AbstractMatrix{ComplexF64}      (vectorized Liouvillian)\n# mJ     :: Vector of sparse jump superoperators\n# rho_ss :: Steady-state density matrix (matrix, not vectorized)\n\n# compute first 3 cumulants\nc1, c2, c3 = fcscumulants_recursive(L, mJ, 3, rho_ss)\n\n#In case we integrate with QuantumOptics.jl;\nusing QuantumOptics\n\n# H :: QuantumOptics.Operator Define your Hamiltonian as a Quantum Optics Operator type\n# J :: Vector{QuantumOptics.Operator} Define your vector containing the jump opterators \n# mJ:: Vector{QuantumOptics.Operator} Define your vector containing the monitored jump operators \n# rho_ss ::QuantumOptics.Operator steady-state density operator\n\nc1, c2, c3 = fcscumulants_recursive(H, J, mJ, 3, rho_ss)\n","category":"page"},{"location":"#QuantumFCS.jl","page":"Home","title":"QuantumFCS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.jl provides tools for Full Counting Statistics (FCS) of quantum systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"-üìò Start with the Quickstart","category":"page"},{"location":"","page":"Home","title":"Home","text":"-üß≠ Browse the API","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#The-math-behind","page":"Home","title":"The math behind","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a general scenario, we consider a Lindblad master equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalLrho = fracd rhodt = -iH rho + sum_k=1^r L_k  rho  L_k^dagger - frac12L^dagger_k L_k rho ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We introduce p le r counting fields N_k with weights nu_k. This lets us define the total current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"N(t) = sum_k nu_k  N_k(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We further define the n-resolved density matrix rho_n(t) whose trace equals the probability to have accumulated n jumps at time t, P(nt) = operatornameTrrho_n(t). Summing over the set of allowed values mathcalN for the total charge N, we retrieve the standard density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho(t) = sum_n in mathcalN rho_n(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We now consider the Fourier transform of the n-resolved density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho_chi(t) = sum_n in mathcalN e^i n chi  rho_n(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"is called the counting field and the time evolution of rho_chi(t) is given by the generalized master equation (GME),","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL_chi  rho_chi = bigl(mathcalL + delta mathcalL_chibigr)rho_chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta mathcalL_chi = sum_k=1^pbigl(1-e^inu_k chibigr)  L_k  (cdot)  L_k^dagger","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computing cumulants using recursive methods","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are ultimately interested in the n-th cumulant langlelangle I^n ranglerangle of the stochastic current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"I(t) = fracdNdt","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we compute through the following recursive scheme,","category":"page"},{"location":"","page":"Home","title":"Home","text":"langlelangle I^n ranglerangle = sum_m=1^n binomnm  langlelangle mathbb1   mathcalL^(m)   rho_textss^(n-m)(chi) ranglerangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"with the constituents,","category":"page"},{"location":"","page":"Home","title":"Home","text":" rho_textss^(n)(chi) ranglerangle = mathcalL^+ sum_m=1^n binomnm Bigl( langlelangle I^m ranglerangle - mathcalL^(m)Bigr)  rho_textss^(n-m) ranglerangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL^(n) = bigl(-i  partial_chibigr)^n mathcalL_chi Big_chi to 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and mathcalL^+ being the Drazin inverse of mathcalL.","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.fcscumulants_recursive","category":"page"},{"location":"#QuantumFCS.fcscumulants_recursive","page":"Home","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse, ComplexF64)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump matrix. By default down jumps have weight -1 and up-jumps have weight +1.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin","category":"page"},{"location":"#QuantumFCS.drazin","page":"Home","title":"QuantumFCS.drazin","text":"drazin(H, J, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary        operator type.\nrho_ss: Density matrix specifying the steady-state of the Liouvillian. By default, it is found through steadystate.eigenvector.         For large matrices the steady-state should be provided, as the best steady-state solver could vary.\n\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.m_jumps","category":"page"},{"location":"#QuantumFCS.m_jumps","page":"Home","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ‚Ñí(n) = ‚àë‚Çñ (ŒΩ‚Çñ)‚Åø (L‚Çñ*)‚äóL‚Çñ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights ŒΩ‚Çñ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator. By default down jumps, J, have weight +1 and up-jumps have weight -1.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin_apply","category":"page"},{"location":"#QuantumFCS.drazin_apply","page":"Home","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of L to Œ± by solving a linear system.\n\nL::SparseMatrixCSC{ComplexF64,Int} (can reuse with F = factorize(L))\nŒ±::SparseVector{ComplexF64,Int}\nœÅ::SparseVector{ComplexF64,Int}   (the steady-state vector)\nvId::AbstractVector{ComplexF64}   (gauge vector)\nF::Union{Nothing,Factorization} (optional factorization of L to reuse)\n\nReturns a SparseVector{ComplexF64,Int} (type-stable).\n\n\n\n\n\ndrazin_apply(L, Œ±, œÅ, vId; F=nothing)\n\nFast apply of the (projected) Drazin inverse for dense L.\n\nL :: Matrix{ComplexF64}\nŒ± :: AbstractVector{ComplexF64}         (dense RHS)\nœÅ :: SparseVector{ComplexF64,Int}       (steady state, sparse)\nvId :: SparseVector{ComplexF64,Int}     (vectorized identity, sparse)\nF :: Union{Nothing,LU}                  (cached lu(L))\n\nReturns Vector{ComplexF64} (type-stable, dense).\n\n\n\n\n\n","category":"function"}]
}
