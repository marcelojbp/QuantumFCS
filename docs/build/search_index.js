var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumFCS]\nOrder   = [:module, :type, :function, :constant]","category":"page"},{"location":"api/#QuantumFCS.drazin-NTuple{4, Any}","page":"API","title":"QuantumFCS.drazin","text":"drazin(L, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nL : Liouvillian matrix\nvrho_ss: vectorised density matrix specifying the steady-state of the Liouvillian.\nvId: vectorised identity matrix (1×N row or vector)\nIdL: Identity matrix in Liouville space (N×N)\n\nReturns\n\nDrazin inverse as a (sparse)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.drazin_apply-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, AbstractVector{ComplexF64}}","page":"API","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, α, ρ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of the Liouvillean L to the vector α by solving a linear system.\n\nArguments\n\nL: Liouvillean operator (matrix).\nα: Right-hand side vector.\nρ: Steady-state vector.\nvId: Vectorized identity vector.\nF: Optional factorization of L to reuse (default: nothing).\nrtol: Relative tolerance for the solver (default: 1e-12).\natol: Absolute tolerance for the solver (default: 0.0).\n\nReturns\n\nA (sparse) vector representing the result of applying the projected Drazin inverse.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.fcscumulants_recursive-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}, Integer, SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, AbstractVector{<:Real}}","page":"API","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse or dense, ComplexF64)\n\nAlternatively, one can provide the Hamiltonian and jump operators instead of L\n\nH: Hamiltonian operator (sparse or dense, Operator from QuantumOptics.jl)\nJ: Vector of jump operators (sparse or dense, Operator from QuantumOptics.jl)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.m_jumps-Tuple{AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}}","page":"API","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ℒ(n) = ∑ₖ (νₖ)ⁿ (Lₖ*)⊗Lₖ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights νₖ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This package provides tools to compute full-counting-statistics cumulants from a Liouvillian.","category":"page"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To install the package, in the Julia REPL, ","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"] add https://github.com/marcelojbp/QuantumFCS","category":"page"},{"location":"quickstart/#Quickstart-examples","page":"Quickstart","title":"Quickstart examples","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using QuantumFCS\n\n# Build your Liouvillian L and monitored jumps mJ\n# L     : Complex sparse/dense matrix   (vectorized Liouvillian)\n# mJ    : Vector of sparse jump super-operators you want to monitor\n# nC    : Number of cumulats to be computed\n# rho_ss : Steady-state density matrix (matrix, not vectorized)\n# nu     : Vector of weighs (same length as mJ) for the monitored jumps\n\nmJ = [sqrt(kappa) * a, sqrt(kappa) * a_dagger] #Monitoring loss and injection of photons\nnu = [-1, 1] #We count -1 if we anihilate and +1 if we create\n# compute first 3 cumulants\nc1, c2, c3 = fcscumulants_recursive(L, mJ, 3, rho_ss, nu)\n\n#In case you want to use QuantumOptics.jl;\nusing QuantumOptics\n\n# H :: QuantumOptics.Operator Define your Hamiltonian as a Quantum Optics Operator type\n# J :: Vector{QuantumOptics.Operator} Define your vector containing the jump opterators \n# mJ:: Vector{QuantumOptics.Operator} Define your vector containing the monitored jump operators \n# rho_ss ::QuantumOptics.Operator steady-state density operator\n\nmJ = [sqrt(kappa) * a, sqrt(kappa) * a_dagger] #Same as above, but here a and a_dagger are QuantumOptics.Operators\nnu = [-1, 1] #Same as above\n\nc1, c2, c3 = fcscumulants_recursive(H, J, mJ, 3, rho_ss, nu)\n","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Quantum-dot-heat-engine","page":"Examples","title":"Quantum dot heat engine","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We study a quantum dot coupled to two fermionic reservoirs, for details on the model see Patrick P. Potts, 2024. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QuantumFCS, LinearAlgebra, SparseArrays\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define parameters and system","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# System parameters\nϵd = 1.0;  # Energy level of the quantum dot\nκc = 0.1;  # Coupling strength to cold reservoir\nκh = 0.5;  # Coupling strength to hot reservoir\nnc = 0.0;  # Occupation number of cold reservoir\nnh = 1.0;  # Occupation number of hot reservoir\n\n# Basis states and identity \noccupied = complex.([0,1]);\nempty = complex.([1,0]);\nid = sparse(1.0I,2,2);\n\n## Operators\n# Hamiltonian \nH = sparse(ϵd * (occupied * occupied'))  \n# Jump operators\nJcloss = sparse(sqrt(κc * (1-nc)) * (empty * occupied'));\nJcgain = sparse(sqrt(κc * nc) * (occupied * empty'));\nJhgain = sparse(sqrt(κh * nh) * (occupied * empty'));\nJhloss = sparse(sqrt(κh * (1-nh)) * (empty * occupied'));","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We construct the Liouvillian ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"## Constructing the Liouvillian\n# Unitary part \nL = -im * (kron(id,H) - kron(transpose(H),id))\n# Jump terms from the dissipators \nL += kron(conj(Jcloss),Jcloss) + kron(conj(Jhloss),Jhloss) + kron(conj(Jhgain),Jhgain)\n# Non-jump terms from the dissipators\nL += (-1/2 * kron(id,Jcloss'*Jcloss) \n     -1/2 * kron(transpose(Jcloss'*Jcloss),id) \n     -1/2 * kron(id,Jcgain'*Jcgain) \n     -1/2 * kron(transpose(Jcgain'*Jcgain),id) \n     -1/2 * kron(id,Jhloss'*Jhloss) \n     -1/2 * kron(transpose(Jhloss'*Jhloss),id)\n     -1/2 * kron(id,Jhgain'*Jhgain) \n     -1/2 * kron(transpose(Jhgain'*Jhgain),id))  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and determine the steady state ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":" # Determining the steady state\nE = eigen(Matrix(L))                       # compute all eigenpairs (fine for small L)\nidx = argmin(abs.(E.values))               # index of eigenvalue closest to zero\nv = E.vectors[:, idx]                      # right eigenvector (vec(ρ))\n\n# reshape back to n×n (vec stacks columns, so reshape(v, n, n) gives the matrix)\nρ_ss = reshape(v, 2, 2);\n\n# numeric cleanup: make Hermitian and normalize trace\nρ_ss = (ρ_ss + ρ_ss') / 2  ;               # enforce Hermiticity (conjugate-transpose)\nρ_ss = ρ_ss / tr(ρ_ss) ;                   # normalize trace to 1","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We choose to monitor the electrons entering the cold reservoir ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Vector with weights \nnu = [1];\n\n# Monitored jump operators (photons entering the cold reservoir)\nmJ = [Jcloss];","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Computing the first two cumulants\nc1, c2 = fcscumulants_recursive(L, mJ, 2, sparse(ρ_ss), nu);\nprintln(\"\\nFull Counting Statistics (numerics):\")\nprintln(\"First cumulant : $c1\")\nprintln(\"Second cumulant : $c2\") ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full Counting Statistics (numerics):\nFirst cumulant : 0.08333333333333334\nSecond cumulant : 0.06018518518518519","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the large bias regime we have the following analytical solutions Patrick P. Potts, 2024","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"c1_analytical = κc*κh/(κc+κh);\nc2_analytical = (κh^2+κc^2)/(κc+κh)^2*c1_analytical;\nprintln(\"\\nFull Counting Statistics (analytical):\")\nprintln(\"First cumulant : $c1_analytical\")\nprintln(\"Second cumulant : $c2_analytical\") ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full Counting Statistics (analytical):\nFirst cumulant : 0.08333333333333334\nSecond cumulant : 0.0601851851851852","category":"page"},{"location":"examples/#Driven-cavity","page":"Examples","title":"Driven cavity","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We study a simple driven cavity using the QuantumOptics.jl package to model the system","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QuantumOptics\nusing QuantumFCS","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define parameters and system ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# Define the Hilbert space dimension \nN = 10  # Fock space cutoff\n\n# Create the Fock basis for the cavity mode\nbasis = FockBasis(N)\n\n# Define operators\na = destroy(basis)  # annihilation operator\na_dag = create(basis)  # creation operator\nn = number(basis)   # number operator\n\n# System parameters\nω = 1.0     # cavity frequency\nκ = 0.1     # cavity decay rate\nΩ = 0.5     # drive strength (coherent drive)\n\n# Hamiltonian (driven cavity)\nH = ω * n + Ω * (a_dag + a)  # free evolution + coherent drive\n\n# Jump operators (cavity decay)\nJ = [sqrt(κ) * a]  # photon loss\n\n# Vector with weights (for one monitored channel)\nnu = [-1]\n\n# Monitored jump operators (photons leaving the cavity)\nmJ = [sqrt(κ) * a]\n\n# Initial state (vacuum state)\nψ0 = fockstate(basis, 0)\nρ0 = dm(ψ0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Determine the steady state ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ρss = steadystate.iterative(H, J);\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Compute the first three cumulants","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"c1, c2, c3 = fcscumulants_recursive(H, J, mJ, 3, ρss, nu)\n\nprintln(\"\\nFull Counting Statistics:\")\nprintln(\"First cumulant (mean photon flux): $c1\")\nprintln(\"Second cumulant (variance): $c2\") \nprintln(\"Third cumulant (skewness): $c3\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Full Counting Statistics:\nFirst cumulant (mean photon flux): -0.02104572040194588\nSecond cumulant (variance): 0.012890993774510551\nThird cumulant (skewness): 0.011185533737017767","category":"page"},{"location":"#QuantumFCS.jl","page":"Home","title":"QuantumFCS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.jl provides tools for Full Counting Statistics (FCS) of quantum systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"-📘 Start with the Quickstart","category":"page"},{"location":"","page":"Home","title":"Home","text":"-🧭 Browse the API","category":"page"},{"location":"","page":"Home","title":"Home","text":"-📝 Study the Examples","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#Mathematical-Background","page":"Home","title":"Mathematical Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a general scenario, we consider a Lindblad master equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalLrho = fracd rhodt = -iH rho + sum_k=1^r L_k  rho  L_k^dagger - frac12L^dagger_k L_k rho ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We introduce p le r counting fields N_k with weights nu_k. This lets us define the total current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"N(t) = sum_k nu_k  N_k(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We further define the n-resolved density matrix rho_n(t) whose trace equals the probability to have accumulated n jumps at time t, P(nt) = operatornameTrrho_n(t). Summing over the set of allowed values mathcalN for the total charge N, we retrieve the standard density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho(t) = sum_n in mathcalN rho_n(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We now consider the Fourier transform of the n-resolved density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"rho_chi(t) = sum_n in mathcalN e^i n chi  rho_n(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"is called the counting field and the time evolution of rho_chi(t) is given by the generalized master equation (GME),","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL_chi  rho_chi = bigl(mathcalL + delta mathcalL_chibigr)rho_chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta mathcalL_chi = sum_k=1^pbigl(1-e^inu_k chibigr)  L_k  (cdot)  L_k^dagger","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computing cumulants using recursive methods","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are ultimately interested in the n-th cumulant langlelangle I^n ranglerangle of the stochastic current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"I(t) = fracdNdt","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we compute through the following recursive scheme,","category":"page"},{"location":"","page":"Home","title":"Home","text":"langlelangle I^n ranglerangle = sum_m=1^n binomnm  langlelangle mathbb1   mathcalL^(m)   rho_textss^(n-m)(chi) ranglerangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"with the constituents,","category":"page"},{"location":"","page":"Home","title":"Home","text":" rho_textss^(n)(chi) ranglerangle = mathcalL^+ sum_m=1^n binomnm Bigl( langlelangle I^m ranglerangle - mathcalL^(m)Bigr)  rho_textss^(n-m) ranglerangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL^(n) = bigl(-i  partial_chibigr)^n mathcalL_chi Big_chi to 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and mathcalL^+ being the Drazin inverse of mathcalL.","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.fcscumulants_recursive","category":"page"},{"location":"#QuantumFCS.fcscumulants_recursive","page":"Home","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse or dense, ComplexF64)\n\nAlternatively, one can provide the Hamiltonian and jump operators instead of L\n\nH: Hamiltonian operator (sparse or dense, Operator from QuantumOptics.jl)\nJ: Vector of jump operators (sparse or dense, Operator from QuantumOptics.jl)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin","category":"page"},{"location":"#QuantumFCS.drazin","page":"Home","title":"QuantumFCS.drazin","text":"drazin(L, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nL : Liouvillian matrix\nvrho_ss: vectorised density matrix specifying the steady-state of the Liouvillian.\nvId: vectorised identity matrix (1×N row or vector)\nIdL: Identity matrix in Liouville space (N×N)\n\nReturns\n\nDrazin inverse as a (sparse)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.m_jumps","category":"page"},{"location":"#QuantumFCS.m_jumps","page":"Home","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ℒ(n) = ∑ₖ (νₖ)ⁿ (Lₖ*)⊗Lₖ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights νₖ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin_apply","category":"page"},{"location":"#QuantumFCS.drazin_apply","page":"Home","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, α, ρ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of the Liouvillean L to the vector α by solving a linear system.\n\nArguments\n\nL: Liouvillean operator (matrix).\nα: Right-hand side vector.\nρ: Steady-state vector.\nvId: Vectorized identity vector.\nF: Optional factorization of L to reuse (default: nothing).\nrtol: Relative tolerance for the solver (default: 1e-12).\natol: Absolute tolerance for the solver (default: 0.0).\n\nReturns\n\nA (sparse) vector representing the result of applying the projected Drazin inverse.\n\n\n\n\n\n","category":"function"}]
}
