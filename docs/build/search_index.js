var documenterSearchIndex = {"docs":
[{"location":"#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Documentation","title":"Introduction","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"As a general scenario, we consider a Lindblad master equations,","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"mathcalLrho =fracd rhodt = -iH rho + sum_k=1^r L_k rho L_k^dagger -frac12leftL^dagger_k L_k rho right","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"We introduce p leq r counting fields N_k with weights nu_k. This lets us define the total current, ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"N(t) = sum_k nu_k N_k(t)  ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"We further define the n-resolved density matrix rho_n(t) whose trace equals the probability to have accumulated n jumps at time t , P(nt) = textTrleft rho_n(t) right. Summing over the set of allowed values  mathcalN for the total charge N , we retrieve the standard density matrix, ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"rho = sum_n in mathcalN rho_n(t)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"We now consider the Fourier transform of the n-resolved density matrix, ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"rho_chi(t) = sum_n in mathcalN e^i n chi rho_n(t)","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"chi is called the counting field and the timeevolution of rho_chi(t) is given by the generalized master equation (GME),","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"mathcalL_chi rho_chi = left(mathcalL + delta mathcalL_chi right)rho_chi","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"where,","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"delta mathcalL_chi = sum_k=1^p(1-e^inu_k chi) L_k rho L_k^dagger ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Computing Cumulants using recursive Methods ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"We are ultimately interested in the n-th cumulant langle langle  I^n rangle rangle of the stochastic current, ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"I(t) = fracdNdt","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"which we compute through the following recursive scheme, ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"langle langle I^n rangle rangle = sum_m=1^n binomnm langle langle mathbb1  mathcalL^(m)  rho_textss^(n-m)(chi) rangle rangle ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"with the constituents, ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":" rho_textss^(n)(chi) rangle rangle = mathcalL^+ sum_m=1^n binomnm left( langle langle I^m rangle rangle - mathcalL^(m)right)  rho_textss^n-m rangle rangle ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"mathcalL^(n) = left left( -i partial_chi right)^n mathcalL_chi right_chi to 0","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"and mathcalL^+ being the Drazin inverse of mathcalL.","category":"page"},{"location":"#Functions","page":"Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"fcscumulants_recursive","category":"page"},{"location":"#QuantumFCS.fcscumulants_recursive","page":"Documentation","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(H, J, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary       operator type.\nmJ: Vector containing the monitored jump operators.\nJdagger=dagger.(Jdagger): Vector containing the hermitian conjugates of the       jump operators. If they are not given they are calculated automatically.\nnu: vector of length 2*length(J) weights for each jump operator. By default down jumps, J, have weight -1 and up-jumps have weight +1.\nkwargs...: Further arguments are passed on to the ode solver.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"drazin","category":"page"},{"location":"#QuantumFCS.drazin","page":"Documentation","title":"QuantumFCS.drazin","text":"drazin(H, J; rho_ss = steadystate.eigenvector(H, J))\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary        operator type.\nrho_ss: Density matrix specifying the steady-state of the Liouvillian. By default, it is found through steadystate.eigenvector.         For large matrices the steady-state should be provided, as the best steady-state solver could vary.\n\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"m_jumps","category":"page"},{"location":"#QuantumFCS.m_jumps","page":"Documentation","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ℒ(n) = ∑ₖ (νₖ)ⁿ (Lₖ*)⊗Lₖ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights νₖ. By default set to 1, since this case appears more often.\nnu: Set of weights νₖ, by default set to -1 for emission and +1 for absorption jumps.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"drazin_apply","category":"page"},{"location":"#QuantumFCS.drazin_apply","page":"Documentation","title":"QuantumFCS.drazin_apply","text":"drazin_apply()\n\nCalculates the vector resulting from the Drazin inverse being applied to another vector. \n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary   operator type.\nρss : steady state of the system as a density matrix\nα : input state as a density matrix\n\n\n\n\n\n","category":"function"},{"location":"#Examples","page":"Documentation","title":"Examples","text":"","category":"section"}]
}
