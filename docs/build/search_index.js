var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumFCS]\nOrder   = [:module, :type, :function, :constant]","category":"page"},{"location":"api/#QuantumFCS.drazin-NTuple{4, Any}","page":"API","title":"QuantumFCS.drazin","text":"drazin(H, J, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary        operator type.\nrho_ss: Density matrix specifying the steady-state of the Liouvillian. By default, it is found through steadystate.eigenvector.         For large matrices the steady-state should be provided, as the best steady-state solver could vary.\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.drazin_apply-Tuple{Matrix{ComplexF64}, AbstractVector{ComplexF64}, SparseArrays.SparseVector{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}}","page":"API","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing)\n\nFast apply of the (projected) Drazin inverse for dense L.\n\nL :: Matrix{ComplexF64}\nŒ± :: AbstractVector{ComplexF64}         (dense RHS)\nœÅ :: SparseVector{ComplexF64,Int}       (steady state, sparse)\nvId :: SparseVector{ComplexF64,Int}     (vectorized identity, sparse)\nF :: Union{Nothing,LU}                  (cached lu(L))\n\nReturns Vector{ComplexF64} (type-stable, dense).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.drazin_apply-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, SparseArrays.SparseVector{ComplexF64, Int64}, AbstractVector{ComplexF64}}","page":"API","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of L to Œ± by solving a linear system.\n\nL::SparseMatrixCSC{ComplexF64,Int} (can reuse with F = factorize(L))\nŒ±::SparseVector{ComplexF64,Int}\nœÅ::SparseVector{ComplexF64,Int}   (the steady-state vector)\nvId::AbstractVector{ComplexF64}   (gauge vector)\nF::Union{Nothing,Factorization} (optional factorization of L to reuse)\n\nReturns a SparseVector{ComplexF64,Int} (type-stable).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.fcscumulants_recursive-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}, Integer, SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}","page":"API","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse, ComplexF64)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump matrix. By default down jumps have weight -1 and up-jumps have weight +1.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumFCS.m_jumps-Tuple{AbstractVector{<:SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}}","page":"API","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ‚Ñí(n) = ‚àë‚Çñ (ŒΩ‚Çñ)‚Åø (L‚Çñ*)‚äóL‚Çñ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights ŒΩ‚Çñ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator. By default down jumps, J, have weight +1 and up-jumps have weight -1.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This package provides tools to compute full-counting-statistics cumulants from a Liouvillian.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Example skeleton (replace with your model):","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using QuantumFCS\n\n# Build your Liouvillian L and monitored jumps mJ\n# L      :: AbstractMatrix{ComplexF64}      (vectorized Liouvillian)\n# mJ     :: Vector of sparse jump superoperators\n# rho_ss :: Steady-state density matrix (matrix, not vectorized)\n\n# compute first 3 cumulants\nc1, c2, c3 = fcscumulants_recursive(L, mJ, 3, rho_ss)","category":"page"},{"location":"#QuantumFCS.jl","page":"Home","title":"QuantumFCS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.jl provides tools for Full Counting Statistics (FCS) of quantum systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"üìò Start with the Quickstart üß≠ Browse the API","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a general scenario, we consider a Lindblad master equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\mathcal{L}\\rho = \\frac{d \\rho}{dt} = -i[H, \\rho] + \\sum{k=1}^r Lk \\, \\rho \\, Lk^\\dagger - \\frac{1}{2}\\left{L^\\daggerk L_k, \\rho \\right}. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"We introduce p le r counting fields N_k with weights nu_k. This lets us define the total current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"N(t) = \\sumk \\nuk \\, N_k(t)~. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"We further define the n-resolved density matrix rho_n(t) whose trace equals the probability to have accumulated n jumps at time t, P(nt) = operatornameTrrho_n(t). Summing over the set of allowed values mathcalN for the total charge N, we retrieve the standard density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\rho(t) = \\sum{n \\in \\mathcal{N}} \\rhon(t)~. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"We now consider the Fourier transform of the n-resolved density matrix,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\rho{\\chi}(t) = \\sum{n \\in \\mathcal{N}} e^{i n \\chi} \\, \\rho_n(t)~. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"chi","category":"page"},{"location":"","page":"Home","title":"Home","text":"is called the counting field and the time evolution of rho_chi(t) is given by the generalized master equation (GME),","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\mathcal{L}\\chi \\, \\rho\\chi = \\bigl(\\mathcal{L} + \\delta \\mathcal{L}\\chi\\bigr)\\rho\\chi, $","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\delta \\mathcal{L}\\chi = \\sum{k=1}^p\\bigl(1-e^{i\\nuk \\chi}\\bigr) \\, Lk \\, (\\cdot) \\, L_k^\\dagger~. $","category":"page"},{"location":"","page":"Home","title":"Home","text":"Computing cumulants using recursive methods","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are ultimately interested in the n-th cumulant langlelangle I^n ranglerangle of the stochastic current,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"I(t) = \\frac{dN}{dt}~, $","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we compute through the following recursive scheme,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\langle!\\langle I^n \\rangle!\\rangle = \\sum{m=1}^n \\binom{n}{m} \\, \\langle!\\langle \\mathbb{1} | \\, \\mathcal{L}^{(m)} \\, | \\rho{\\text{ss}}^{(n-m)}(\\chi) \\rangle!\\rangle~, $","category":"page"},{"location":"","page":"Home","title":"Home","text":"with the constituents,","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"| \\rho{\\text{ss}}^{(n)}(\\chi) \\rangle!\\rangle = \\mathcal{L}^+ \\sum{m=1}^n \\binom{n}{m} \\Bigl( \\langle!\\langle I^m \\rangle!\\rangle - \\mathcal{L}^{(m)}\\Bigr) | \\rho_{\\text{ss}}^{(n-m)} \\rangle!\\rangle~, $","category":"page"},{"location":"","page":"Home","title":"Home","text":"$","category":"page"},{"location":"","page":"Home","title":"Home","text":"\\mathcal{L}^{(n)} = \\left.\\bigl(-i \\, \\partial{\\chi}\\bigr)^n \\mathcal{L}\\chi \\right|_{\\chi \\to 0}~, $","category":"page"},{"location":"","page":"Home","title":"Home","text":"and mathcalL^+ being the Drazin inverse of mathcalL.","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.fcscumulants_recursive","category":"page"},{"location":"#QuantumFCS.fcscumulants_recursive","page":"Home","title":"QuantumFCS.fcscumulants_recursive","text":"fcscumulants_recursive(L, mJ, nC; <keyword arguments>)\n\nCalculate n-th zero-frequency cumulant of full counting statistics using a recursive scheme.\n\nArguments\n\nL: Vectorized Liouvillian matrix (sparse, ComplexF64)\nmJ: Vector containing the monitored jump matrices (sparse operators in vectorized representation).\nnC: Number of cumulants to be calculated.\nnu: Vector of length length(mJ) with weights for each jump matrix. By default down jumps have weight -1 and up-jumps have weight +1.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin","category":"page"},{"location":"#QuantumFCS.drazin","page":"Home","title":"QuantumFCS.drazin","text":"drazin(H, J, vrho_ss, vId, IdL)\n\nCalculate the Drazin inverse of a Liouvillian defined by the Hamiltonian H and jump operators J.\n\nArguments\n\nH: Arbitrary operator specifying the Hamiltonian.\nJ: Vector containing all jump operators which can be of any arbitrary        operator type.\nrho_ss: Density matrix specifying the steady-state of the Liouvillian. By default, it is found through steadystate.eigenvector.         For large matrices the steady-state should be provided, as the best steady-state solver could vary.\n\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.m_jumps","category":"page"},{"location":"#QuantumFCS.m_jumps","page":"Home","title":"QuantumFCS.m_jumps","text":"m_jumps(mJ; n=1; nu = vcat(fill(-1, Int(length(J)/2)),fill(1, Int(length(J)/2))))\n\nCalculate the vectorized super-operator ‚Ñí(n) = ‚àë‚Çñ (ŒΩ‚Çñ)‚Åø (L‚Çñ*)‚äóL‚Çñ.      \n\nArguments\n\nmJ: List of monitored jumps\nn : Power of the weights ŒΩ‚Çñ. By default set to 1, since this case appears more often.\nnu: vector of length length(mJ) with weights for each jump operator. By default down jumps, J, have weight +1 and up-jumps have weight -1.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"QuantumFCS.drazin_apply","category":"page"},{"location":"#QuantumFCS.drazin_apply","page":"Home","title":"QuantumFCS.drazin_apply","text":"drazin_apply(L, Œ±, œÅ, vId; F=nothing, rtol=1e-12, atol=0.0)\n\nApply the (projected) Drazin inverse of L to Œ± by solving a linear system.\n\nL::SparseMatrixCSC{ComplexF64,Int} (can reuse with F = factorize(L))\nŒ±::SparseVector{ComplexF64,Int}\nœÅ::SparseVector{ComplexF64,Int}   (the steady-state vector)\nvId::AbstractVector{ComplexF64}   (gauge vector)\nF::Union{Nothing,Factorization} (optional factorization of L to reuse)\n\nReturns a SparseVector{ComplexF64,Int} (type-stable).\n\n\n\n\n\ndrazin_apply(L, Œ±, œÅ, vId; F=nothing)\n\nFast apply of the (projected) Drazin inverse for dense L.\n\nL :: Matrix{ComplexF64}\nŒ± :: AbstractVector{ComplexF64}         (dense RHS)\nœÅ :: SparseVector{ComplexF64,Int}       (steady state, sparse)\nvId :: SparseVector{ComplexF64,Int}     (vectorized identity, sparse)\nF :: Union{Nothing,LU}                  (cached lu(L))\n\nReturns Vector{ComplexF64} (type-stable, dense).\n\n\n\n\n\n","category":"function"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"}]
}
